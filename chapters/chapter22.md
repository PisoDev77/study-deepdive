__Deep Dive 22장__

# this

## this 키워드가 왜 있을까요?
'객체지향 프로그래밍'에서 객체는 상태(state)를 나타내는 프로퍼티와 동작(behavior)을 나타내는 메서드를 하나의 논리적인 단위로 묶는 즉 캡슐화한 자료구조다. 그래서 __메서드__ 는 객체의 상태를 즉 프로퍼티를 참조하고 변경해야 한다. 그렇다면 자기자신 즉 생성된 객체를 가리키는 식별자를 참조할 수 있어야한다. 

## this는 인스턴스를 참조하는 식별자인가요?
this는 자신이 속한 객체 또는 생성할 인스턴스를 가리키는 자기 참조 변수라 말할 수 있다. this는 암묵적으로 함수 호출 시 함수 내부에 arguments객체와 this가 전달된다. this가 지역 변수처럼 사용할 수 있다. 이때, this의 연결 즉 바인딩은 호출 방식에 의해 동적으로 결정된다.

## this 바인딩이 동적으로 결정된다는 것은?
this와 arguments객체가 함수 호출시 함수내부로 전달된다는 이야기 있었다. 함수 내부가 생성되면 식별자처럼 arguments 객체와 this의 정보를 담는 공간이 생성된다는 말이다. 그때 this를 연결해준다. 그 순간의 인스턴스나, 호출한 객체에 this를 연결한다.

## this는 strict mode에서 undefined로 바인딩되잖아요.
이는 엄격모드에서 일반 함수는 인스턴스나 호출한 객체를 참조할 일이 없고, 함수를 샐힝한다는 의미로 사용된다. 결국 this에 undefined를 연결하여, 일반함수로 사용된다고 암묵적으로 명시한다.

## 호출하는 방식은 다양한데, 그 방식마다 다른가요?
호출방식은 일반함수 호출과 메서드 호출 그리고 생성자 함수 호출 마지막으로 간접 호출이 있다. 
### 일반 함수는 this가 기본적으로 전역객체에 바인딩된다.

### 메서드를 호출한 객체에 this는 바인딩된다.

### 생성자 함수를 호출할 때에는 생성할 인스턴스에 바인딩된다.

### apply/call/bind 메서드에 의한 간접호출 때 바인딩된다.
apply와 call은 함수를 호출할 때 사용한다. 인수를 전달하는 방식에 차이가 있다. 대신 함수  호출시 this로 사용할 객체를 인수로 넘겨준다. 왜냐하면, 함수 내부로 this로 연결될 객체를 전달한다는 의미다. 

#### 대표적 용도로는 유사 배열 객체에 배열 메서드를 사용할 때이다.
arguments는 유사배열객체다. 왜냐하면, length와 인덱스를 프로퍼티를 가지고 있다.  

### bind는 호출이 아니라 this 바인딩을 새로 생성해 함수객체를 반환해준다.